# L-01 — Domain Error Hierarchy (Developer Guide)

Purpose: define a small, cohesive exception hierarchy for the domain layer that is easy to raise, catch, and map to user-facing messages without leaking provider or infrastructure concerns.

## Outcomes

- A dedicated error module in the domain package that exposes a stable public API of domain-specific exceptions.
- Clear guidance on when to raise which exception.
- Consistent, human-readable messages with optional causal chaining.
- Tests that verify hierarchy, construction, and handling semantics.

## Scope

- In-domain exceptions only (no provider/network/filesystem exceptions).
- No error codes or i18n yet; messages are English strings.
- No logging in constructors; callers log at appropriate layers.
- No domain events; raising exceptions suffices for control-flow in MVP.

## Constraints and Conventions

- Python 3.11+ typing; exceptions derive from `Exception` (not `BaseException`).
- All domain exceptions inherit from a single `DomainError` base.
- Subclasses model semantic categories, not technical transport causes.
- Messages are concise sentences; include key identifiers when useful.
- Optional `cause` chaining uses native exception chaining (`raise X from e`).

## Module Layout

- Location: `liriac/domain/errors.py` (or `liriac/domain/errors/__init__.py` if the project prefers a package; pick one and keep it consistent).
- Re-export the public classes in `__all__` for clean imports: `from liriac.domain.errors import DomainError, ...`.
- Do not depend on any other domain modules to avoid import cycles.

## Public API (classes)

- DomainError: base class for all domain-level exceptions.
- InvariantViolation(DomainError): raised when an entity/VO invariant is violated (e.g., invalid title or negative token count).
- ConcurrencyConflict(DomainError): raised when a write would conflict with concurrent changes detectable at the app layer (placeholder for MVP).
- AppendRejected(DomainError): raised by Chapter append operation when a non-append modification is attempted.
- SlugInvalid(InvariantViolation): specialized invalid-input error with user-actionable guidance.
- ContextOverBudget(DomainError): planning result exceeded budget; can be raised in strict mode or surfaced as a return elsewhere.

Note: `SlugInvalid` inheriting from `InvariantViolation` allows catching either specifically or broadly.

## Design Guidelines

- Prefer the most specific exception that accurately communicates what went wrong; callers can catch by base class when grouping.
- Keep exception messages free of implementation details (e.g., tokenizer names, SDK ids).
- Include important business identifiers in messages (e.g., `ChapterId` or `Slug`) when it improves diagnostics.
- Do not include raw user-provided content in full; summarize or include sanitized identifiers only.

## Message Formatting

- First sentence states the problem succinctly: “Slug is invalid: 'My Book' (must be lowercase-hyphenated).”
- When relevant, mention the violated rule or expected format.
- Avoid trailing punctuation clutter; one sentence is often sufficient.
- Use single quotes around user-supplied atomic values like ids or slugs.

## Exception Chaining

- When converting from a lower-layer exception to a domain exception, chain the cause using `from`.
- Only chain when the lower-layer error meaningfully contributes to debugging; otherwise, raise the domain error alone.
- Do not store the original exception on custom attributes; rely on native `__cause__`.

## Carrying Context

- Keep exception attributes minimal: `message: str` plus optional structured fields like `slug: str` or `chapter_id: str` when commonly needed by handlers.
- Ensure `str(exc)` yields the human-readable message (do not override `__repr__` to be user-facing).
- Avoid mutable attributes; exceptions are effectively immutable.

## Usage Patterns

- Value Objects:
  - Validate in constructors/factories; raise `InvariantViolation` or specialized subclass (e.g., `SlugInvalid`) on bad input.
- Entities:
  - Guard invariants at mutation points; raise `InvariantViolation` for illegal state transitions.
- Chapter append-only:
  - When a delta would rewrite previous content, raise `AppendRejected`.
- Context planning:
  - If operating in strict mode, raise `ContextOverBudget` with a concise summary of the overrun; otherwise, return a preview object.

## Anti-Patterns

- Using `ValueError`, `RuntimeError`, or other built-ins in domain code.
- Catching broad `Exception` in domain modules.
- Including UI guidance like “Click the button to retry” in messages (belongs to app/TUI).
- Abusing exceptions for normal control flow that should be handled by return values.

## App-Layer Mapping

- CLI/TUI should catch `DomainError` at boundaries and map to:
  - Message lines for the user (use `str(e)`).
  - Exit codes or non-interactive error states.
- For `ContextOverBudget`, surface a friendly action: “Reduce previous chapters or trim summaries,” keeping mapper logic outside domain.

## Testing Strategy

- Location: `tests/domain/test_errors.py` (or similar).
- Tests:
  - Class hierarchy: `issubclass` relationships and catching behavior.
  - Construction: messages render as expected via `str()`.
  - Specialized subclass (e.g., `SlugInvalid`) behaves as `InvariantViolation` when caught broadly.
  - Chaining: `__cause__` is set when raised with `from`.
- Do not test formatting via fragile full-string matches when it risks brittleness; focus on key substrings and class identity.
- Parametrize cases for common invalid inputs (e.g., bad slugs) to ensure consistency.

## Migration and Backwards Compatibility

- If earlier code raised built-ins, refactor to raise domain exceptions; add transitional catch-and-rethrow at app boundaries if needed.
- Keep exception names stable; any renaming must preserve import paths or provide aliases.

## Documentation and Discoverability

- Each exception class should have a succinct docstring stating:
  - When it is raised.
  - What the user can do to resolve it (in neutral, domain terms).
- Update design docs index to reference the module path for errors.

## Implementation Notes (non-code)

- Keep the file small and focused; avoid imports from other domain modules.
- Add `__all__` to explicitly export the public classes.
- Keep the number of subclasses minimal for MVP; add new ones only when they enable clearer error handling.

## Acceptance Criteria (recap)

- The error classes exist under the agreed path and are importable.
- Tests confirm hierarchy, messages, and chaining.
- Domain code stubs use the new exceptions in the right places.
- Docs and docstrings reflect intended usage and mapping responsibilities.
