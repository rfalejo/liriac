# Ticket BL-006: Structured JSON Logging and Local Metrics Adapter

## Description
Introduce a structured logging adapter that emits JSON logs and a local metrics adapter that persists lightweight counters and timing summaries to the filesystem. Both components live in Infra, are strictly typed, have no network calls, and follow the projectâ€™s conventions for atomic writes, no `print`, and secret redaction.

Goals:
- Logging: application-wide, structured JSON logs to stderr using stdlib `logging` with a custom JSON formatter. Include contextual fields, consistent timestamps, and exception serialization. Provide simple helpers to integrate without leaking implicit `Any`.
- Metrics: a tiny, file-based recorder that aggregates counters and timing stats and persists to `<book>/.liriac/metrics.json` via atomic writes. No rotation or external telemetry.

Out of scope:
- Wiring logs/metrics across all app layers (initial entry points only).
- Advanced metrics (histograms/percentiles beyond min/max/avg).
- Log shipping, remote collectors, or external metrics backends.

## Acceptance Criteria
- Infra Logging:
  - `src/liriac/infra/logging.py` implements:
    - `get_json_logger(name: str | None = None, level: int | str = "INFO") -> logging.Logger`
      - Returns a configured stdlib `Logger` that writes JSON to stderr.
      - Idempotent configuration: multiple calls do not add duplicate handlers.
      - Accepts `level` as string (`"DEBUG"`, `"INFO"`, etc.) or int.
    - JSON record schema (keys present for all non-exception logs):
      - `time` (RFC 3339/ISO 8601, UTC), `level`, `logger`, `message`, `module`, `func`, `line`, `pid`, `thread`.
      - Extra fields passed via `extra={"ctx": {...}}` are nested under `ctx` (must be JSON-serializable).
    - Exception logging:
      - When `exc_info=True` or via `logger.exception(...)`, include `exc_type`, `exc_message`, and `exc_traceback` (string with newlines).
    - Redaction utilities:
      - `redact_value(value: str) -> str` that masks the middle of secrets (e.g., `sk-...`).
      - `redact_keys(data: Mapping[str, object]) -> dict[str, object]` that masks values for keys matching case-insensitive substrings: `"key"`, `"token"`, `"secret"`, `"password"`, `"authorization"`.
    - No third-party dependencies; only stdlib + typing; fully annotated; `__all__` exports helpers.

- Infra Metrics:
  - `src/liriac/infra/metrics.py` implements:
    - `class MetricsRecorder`:
      - `__init__(base_dir: Path)` targets `<base_dir>/.liriac/metrics.json`.
      - `increment(name: str, value: int = 1) -> None` updates counters.
      - `observe(name: str, seconds: float) -> None` records a duration sample (seconds).
      - `snapshot() -> dict[str, object]` returns current in-memory aggregate:
        - `{"version": 1, "updated_at": "<UTC ISO>", "counters": {...}, "timers": { "<name>": {"count": int, "min": float, "max": float, "avg": float} }}`.
      - `flush() -> None` writes JSON atomically:
        - Ensures `<base_dir>/.liriac/` exists.
        - Writes UTF-8 with `\n` and replaces the final file using `os.replace` (no temp files left behind).
      - No mutation of external inputs; no global state; thread-safe enough for single-process usage (no locks required).
    - Use only stdlib (`pathlib`, `os`, `io`, `json`, `time`, `datetime`); fully annotated; `__all__` exports `MetricsRecorder`.

- Packaging and Exposure:
  - No new runtime dependencies required.
  - `src/liriac/infra/__init__.py` re-exports `get_json_logger`, `redact_value`, `redact_keys`, and `MetricsRecorder` via `__all__`.

- Tests:
  - `tests/infra/test_logging.py` covers:
    - Creating a logger and emitting an info log; parse captured stderr as JSON and assert required keys and UTC timestamp format (`Z` or explicit `+00:00`).
    - Emitting with `extra={"ctx": {"book": "demo"}}` places context under `ctx`.
    - Using `logger.exception("msg")` includes `exc_type`, `exc_message`, and non-empty `exc_traceback`.
    - Redaction helpers mask typical secret-like values and keys.
    - Prevent duplicate handlers: multiple calls to `get_json_logger` do not duplicate output lines.
  - `tests/infra/test_metrics.py` covers:
    - `increment` and `observe` update in-memory state; `snapshot` returns expected structure.
    - `flush` creates `<base_dir>/.liriac/metrics.json` with valid JSON; includes `updated_at` and aggregates.
    - Atomic write: after `flush`, only the final file exists; no `*.tmp` leftovers in the directory.
    - Repeated `flush` updates `updated_at` and persists accumulated counts/timers.
    - All tests avoid network, use `tmp_path`, and do not require existing books.

- Typing and Style:
  - Code is fully annotated; `mypy --strict` passes with zero errors.
  - `ruff` and `black` pass with no changes after initial format.
  - No `print` statements; use only structured logging.

## Testing Strategy
- Logging tests:
  - Use `capsys` or `capfd` to capture stderr; emit logs and `json.loads()` each line.
  - Validate timestamp is parseable by `datetime.fromisoformat` after normalizing `Z` to `+00:00`.
  - Trigger an exception path via a deliberate `try/except` and `logger.exception(...)` to assert exception fields presence.
  - Verify duplicate-handler protection by logging twice after two `get_json_logger()` calls and asserting a single JSON line per `.info(...)` call.

- Metrics tests:
  - Build a `MetricsRecorder` with `tmp_path / "book"`; call `increment("suggestions_total", 2)` and `observe("suggestion_seconds", 0.012)`.
  - Assert `snapshot()` returns correct counters and timing aggregates; `flush()` writes expected JSON to `<base_dir>/.liriac/metrics.json`.
  - Confirm newline at EOF and absence of temp files (glob `*.tmp`).
  - Invoke `flush()` twice to ensure stable accumulation and updated `updated_at`.

- Quality gates:
  - `make fmt`, `make lint`, `make typecheck`, and `make test` all succeed with the new modules and tests.
