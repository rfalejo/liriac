# BL-006 — Autosave (idempotent save + snapshots)

Status: Planned  
Owner: TBA  
Labels: backend, api, autosave, checksum, snapshots, validation  
Blocks: BL-014 (Autosave — frontend)  
Depends on: BL-004 (models), BL-005 (DRF endpoints/base)

## Summary
Add an idempotent autosave endpoint that persists chapter content only when the hash changes. On significant changes, write a `ChapterVersion` snapshot with `diff_size` metadata. Validate checksums, ensure concurrency safety, and return a stable response indicating whether a save occurred.

## Goals
- Provide `POST /api/v1/chapters/{chapter_id}/autosave/` with request `{ body, checksum }`.
- Idempotent behavior: no-op when client checksum matches stored chapter checksum.
- Server-verified integrity: server-computed hash must equal provided `checksum`.
- Snapshots: create `ChapterVersion` only when absolute diff ≥ 100 characters.
- Concurrency-safety: perform update and optional snapshot in a single atomic transaction.
- Clear response: `{ saved: boolean, checksum: string, saved_at: datetime }`.
- Logging/metrics hooks for observability (counters, durations) — minimal for MVP.

## Non-Goals
- Editor UX and IndexedDB mirroring (BL-014 covers frontend autosave).
- Suggestion accept/merge flows (separate tickets).
- Version diff algorithm beyond simple character delta.
- Authentication/authorization (MVP is local-only).

## API Surface
- `POST /api/v1/chapters/{id}/autosave/`
  - Request: `{"body": string, "checksum": string}`.
  - Responses:
    - 200 OK on success with JSON: `{"saved": bool, "checksum": string, "saved_at": "<iso-8601>"}`.
    - 400 Bad Request on validation errors (invalid checksum format, mismatch with body).
    - 404 Not Found if chapter does not exist.

## Schemas (shapes)
- AutosaveRequest
  - Request: `{ body: str, checksum: str }`
- AutosaveResponse
  - Response: `{ saved: bool, checksum: str, saved_at: datetime }`

## Validation
- `checksum` must match regex `^[0-9a-f]{64}$`.
- Server recomputes `sha256(body)`; must equal provided `checksum` (else 400 with field error).
- Idempotency check: compare provided checksum vs stored `Chapter.checksum`.
- Snapshot threshold: `abs(len(new_body) - len(old_body)) >= 100` → create `ChapterVersion`.

## Concurrency & Atomicity
- Use `transaction.atomic()` and `select_for_update()` on the target `Chapter` row.
- Single transaction must:
  1. Re-read the current chapter (locked).
  2. Re-evaluate idempotency (guard against races).
  3. Update chapter fields (`body`, `checksum`) if changed.
  4. Optionally create `ChapterVersion`.
- Return the final persisted checksum and timestamp.

## Error Handling
- 400: invalid checksum format (`checksum` field).
- 400: checksum does not match provided body (`non_field_errors` or `checksum`).
- 404: chapter not found.
- 405: reject non-POST methods (default DRF behavior acceptable).

## Implementation Plan
- Serializer: `AutosaveSerializer` in `apps.library.api.serializers` or `apps.autosave.api.serializers` (keep together with library API for MVP).
  - Fields: `body`, `checksum`; validates format and body/hash consistency.
- View: `ChapterAutosaveAPIView` in `apps.library.api.views`
  - Path: `path("chapters/<int:id>/autosave/", ChapterAutosaveAPIView.as_view())`
  - Looks up chapter, runs service, returns `AutosaveResponse` shape.
- Service: `apps.autosave.services.autosave.AutosaveService`
  - `autosave(chapter_id: int, body: str, checksum: str) -> dict`
  - Handles transaction, locking, update, snapshot policy.
  - Computes `diff_size = abs(len(new_body) - len(old_body))`.
- Routing: include under `/api/v1/` alongside existing library API urls.
- OpenAPI: add request/response components and path to `schema.yaml`.
- Types: run `make fe-typegen` to regenerate `frontend/src/api/types.ts`.

Pseudo-code:

```py
@transaction.atomic
def autosave(chapter_id, body, checksum):
    ch = Chapter.objects.select_for_update().get(pk=chapter_id)

    # Server-side recompute
    if sha256(body) != checksum:
        raise ValidationError({"checksum": ["Checksum does not match body."]})

    # Idempotent no-op
    if checksum == ch.checksum:
        return {"saved": False, "checksum": ch.checksum, "saved_at": ch.updated_at}

    old_body = ch.body
    ch.body = body
    ch.checksum = checksum
    ch.save(update_fields=["body", "checksum", "updated_at"])

    diff_size = abs(len(body) - len(old_body))
    if diff_size >= 100:
        ChapterVersion.objects.create(
            chapter=ch, body=body, checksum=checksum, diff_size=diff_size
        )

    return {"saved": True, "checksum": checksum, "saved_at": ch.updated_at}
```

## Tests (pytest)
- Unit/service tests
  - Idempotent no-op when checksums equal; returns `saved=False`.
  - Save occurs when checksum differs; returns `saved=True` and updates `Chapter`.
  - Snapshot created only on diff ≥ 100; below threshold creates no `ChapterVersion`.
  - Server recompute mismatch triggers 400.
  - Concurrency: simulate two concurrent saves; later transaction sees updated checksum and no-ops.
- API tests
  - 200 with correct shape and timestamps; `Content-Type: application/json`.
  - 400 for invalid checksum format and checksum/body mismatch.
  - 404 for missing chapter.
  - Method not allowed for GET/PUT/PATCH/DELETE.

## OpenAPI & Types
- Update `backend/schema.yaml`:
  - Add `paths./api/v1/chapters/{id}/autosave/` (POST).
  - Add `AutosaveRequest`, `AutosaveResponse` schemas.
- Regenerate frontend DTOs:
  - `make schema`
  - `make fe-typegen` → updates `frontend/src/api/types.ts`.

## Docs
- Add brief endpoint notes to `docs/00-draft.md` (Autosave section already references behavior; ensure it matches response shape).
- Optional: add `docs/api.md` autosave examples.

## Acceptance Criteria
- Endpoint responds with 200 and `{ saved, checksum, saved_at }` on valid requests.
- Idempotency: repeated POST with same `{ body, checksum }` returns `saved=false`, no snapshot.
- Snapshots only when diff ≥ 100; `ChapterVersion.diff_size` stored.
- Validation errors:
  - invalid checksum format,
  - checksum/body mismatch.
- Concurrency-safe updates (no duplicate snapshots or stale writes).
- `make check` passes (lint, typecheck, tests); OpenAPI/types up to date.

## Request/Response Examples

- Autosave (no change)
```
POST /api/v1/chapters/10/autosave/
{ "body": "The pier...", "checksum": "a3f4...d9c0" }

200
{ "saved": false, "checksum": "a3f4...d9c0", "saved_at": "2025-09-17T03:45:12Z" }
```

- Autosave (with change, snapshot created)
```
POST /api/v1/chapters/10/autosave/
{ "body": "The pier... (longer by 120 chars)", "checksum": "b5e1...2a77" }

200
{ "saved": true, "checksum": "b5e1...2a77", "saved_at": "2025-09-17T03:46:02Z" }
```

- Invalid checksum (format)
```
POST /api/v1/chapters/10/autosave/
{ "body": "...", "checksum": "not-64-hex" }

400
{ "checksum": ["Invalid checksum format"] }
```

- Mismatch (checksum != sha256(body))
```
POST /api/v1/chapters/10/autosave/
{ "body": "abc", "checksum": "ffffffff..." }

400
{ "checksum": ["Checksum does not match body."] }
```

## Risks & Mitigations
- Race conditions: use row-level locking and re-check idempotency inside transaction.
- Snapshot bloat: enforce threshold; consider cap/retention later.
- Large bodies: avoid expensive diffing; use simple length-based `diff_size` for MVP.
- Client drift: rely on server-side checksum recompute to ensure integrity.

## Estimation
- Effort: M (1–2 days including tests, schema, and docs).

## Checklist
- [ ] Serializer and view implemented.
- [ ] Service with transaction + locking.
- [ ] URL route registered under `/api/v1/`.
- [ ] OpenAPI schema updated; TS types regenerated.
- [ ] Tests: service + API passing.
- [ ] Lint/format/typecheck clean.
