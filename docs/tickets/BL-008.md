# BL-008 — Suggestions WebSocket Consumer

Status: Planned  
Owner: TBA  
Labels: backend, channels, websocket, suggestions, streaming, cancellation  
Blocks: BL-015 (Suggestions UI)  
Depends on: BL-004 (models), BL-005 (DRF endpoints/base), BL-007 (Suggestions Service)

## Summary
Expose a Django Channels WebSocket consumer that streams AI suggestion events to clients. The consumer wraps `SuggestionsService` (BL-007), relays normalized events (`delta`, `usage`, `done`, `error`) to the client in real time, and supports cooperative cancellation via a `stop` control message. This unlocks the frontend suggestions drawer (BL-015) with live token streaming.

## Goals
- WebSocket path: `/ws/suggestions/{session_id}/` (primary), optional handshake path `/ws/suggestions/` for "start-on-connect".
- Event relay: send `delta`, `usage`, `done`, `error` as normalized JSON frames.
- Cancellation: honor `{"type": "stop"}` from client; send a final `done` and close gracefully.
- Session lifecycle: one running stream per connection; clean up background tasks and cancel tokens on disconnect.
- Validation and errors: close on invalid/missing inputs; emit `error` messages for recoverable issues.
- Observability: structured logs for connect, start, stop, errors, completion.

## Non-Goals
- REST endpoints to start/accept/reject suggestions (covered separately in BL-015 or follow-ups).
- Authentication/authorization and ACLs (MVP is local-only).
- Event replay across reconnects (MVP streams live; replay can be considered later).

## WebSocket Contract

### Path(s)
- Primary: `/ws/suggestions/{session_id}/`
  - `session_id` is a UUID referring to the logical session on the server.
  - In MVP, the session is created at stream start; this path still returns the effective `session_id` to the client via a `started` message.
- Optional (MVP convenience): `/ws/suggestions/`
  - Allows "start on connect" without pre-allocating a `session_id` (useful before the REST start endpoint exists).

### Client → Server (incoming)
- `{"type": "start", "chapter_id": number, "prompt": string, "settings"?: object, "context"?: object}`
  - Starts a provider stream through `SuggestionsService.start(...)`.
  - On success, server responds with `{"type":"started","session_id": "<uuid>"}` then begins streaming events.
  - Only allowed once per connection; duplicate `start` → `error` then close.
  - `settings` maps to `ProviderSettings` (subset: `model`, `temperature`, `max_tokens`, `stop`).
  - `context` maps to `ProviderContext` (subset: `system_prompt`, `personas`, `chapter_titles`).
- `{"type": "stop"}`
  - Cancels the running session (idempotent). Server emits a final `done` and closes.

### Server → Client (outgoing)
- `{"type": "started", "session_id": "<uuid>"}` — acknowledgement of `start`.
- `{"type": "delta", "value": string}` — incremental generated text chunk.
- `{"type": "usage", "prompt_tokens": int, "completion_tokens": int, "total_tokens": int}` — usage summary.
- `{"type": "error", "message": string, "code"?: string, "retryable"?: boolean}` — non-fatal provider/service error; connection closes after sending.
- `{"type": "done"}` — terminal event; connection closes after sending.

### Close semantics
- Normal completion: close code `1000` after `done`.
- Invalid input/not found: close with application error (e.g., `4404` for session not found, `4400` for bad request).
- Internal error: close `1011` after sending an `error` frame if possible.

## Flow (MVP)
1. Client connects to `/ws/suggestions/` (or `/ws/suggestions/{session_id}/` if preferring path-based ids).
2. Client sends `start` with `chapter_id`, `prompt`, and optional `settings`/`context`.
3. Server:
   - Validates payload, calls `SuggestionsService.start(...)`.
   - Sends `started` with the assigned `session_id`.
   - Streams events to client as they arrive; persists via service (BL-007).
4. Client may send `stop` at any time; server cancels via `SuggestionsService.cancel(session_id)`, emits `done`, and closes.
5. On provider `error`, server emits `error`, updates `Suggestion.status="rejected"`, and closes.

Note: In a later iteration (with REST start), the SPA will `POST /api/v1/chapters/{id}/suggestions/` to create a session and receive a `ws_url` (`/ws/suggestions/{session_id}/`). The consumer will then validate the `session_id` and start streaming without requiring a `start` message. This ticket may implement both modes; MVP requires at least the "start-on-connect" mode.

## Implementation Plan

- Consumer
  - File: `apps/suggestions/consumers.py`
  - Class: `SuggestionsConsumer(AsyncWebsocketConsumer)`
  - Responsibilities:
    - Accept connection immediately.
    - On first `start` message:
      - Validate payload (lightweight schema check).
      - Call `SuggestionsService.start(...)` with `chapter_id`, `prompt`, and optional `settings`/`context`.
      - Store `session_id` + `CancelToken` mapping implicitly via service registry.
      - Send `started` ack, spawn background task to relay provider events to client via `send_json(...)`.
    - On `stop`:
      - Call `SuggestionsService.cancel(session_id)` (idempotent), flush a final `done`, then close.
    - On disconnect:
      - Cancel background task (if any) and ensure session is cleaned up by service.
- Routing
  - Update `liriac/routing.py`:
    - `path("ws/suggestions/", SuggestionsConsumer.as_asgi())`
    - `path("ws/suggestions/<uuid:session_id>/", SuggestionsConsumer.as_asgi())` (optional attach path for future REST-first flow).
- Validation
  - Minimal inline validation for `start` payload:
    - `chapter_id: int`, `prompt: non-empty str`.
    - Optional `settings` fields: `model: str`, `temperature: float`, `max_tokens: int|null`, `stop: list[str]|null`.
    - Optional `context` fields: `system_prompt: str`, `personas?: list[str]`, `chapter_titles?: list[str]`.
  - On invalid payload: send `error` and close `4400`.
- Concurrency & Safety
  - Disallow multiple `start` per connection (track state).
  - Background relay task reads events from the async iterator and forwards as-is.
  - Ensure cleanup in `finally`: cancel token via `cancel(session_id)` and drop background task.
- Observability
  - Log connect/started/stop/done/error with `session_id`, `chapter_id`, and durations where feasible.

## Pseudo-code (Consumer)

```py
# apps/suggestions/consumers.py
class SuggestionsConsumer(AsyncWebsocketConsumer):
    session_id: uuid.UUID | None = None
    relay_task: asyncio.Task | None = None
    started: bool = False

    async def connect(self) -> None:
        await self.accept()

    async def disconnect(self, close_code: int) -> None:
        if self.session_id:
            SuggestionsService.cancel(self.session_id)
        if self.relay_task:
            self.relay_task.cancel()

    async def receive_json(self, content: dict[str, Any]) -> None:
        t = content.get("type")
        if t == "start":
            if self.started:
                await self.send_json({"type": "error", "message": "Already started"})
                await self.close(code=4400)
                return
            chapter_id = int(content.get("chapter_id", 0))
            prompt = (content.get("prompt") or "").strip()
            if not chapter_id or not prompt:
                await self.send_json({"type": "error", "message": "Invalid payload"})
                await self.close(code=4400)
                return
            settings = ProviderSettings(**(content.get("settings") or {}))
            context = ProviderContext(**(content.get("context") or {}))
            self.session_id, aiter = await SuggestionsService.start(
                chapter_id=chapter_id, prompt=prompt, settings=settings, context=context
            )
            self.started = True
            await self.send_json({"type": "started", "session_id": str(self.session_id)})

            async def relay() -> None:
                async for ev in aiter:
                    await self.send_json(dataclasses.asdict(ev))
                await self.close(code=1000)

            self.relay_task = asyncio.create_task(relay())
        elif t == "stop":
            if self.session_id:
                SuggestionsService.cancel(self.session_id)
        else:
            await self.send_json({"type": "error", "message": "Unknown message type"})
            await self.close(code=4400)
```

## Tests (pytest + Channels)

- `TestSuggestionsConsumer` (new file under `backend/tests/`):
  - `test_connect_start_stream_done`:
    - Connect to `/ws/suggestions/`.
    - Send `start` with a simple prompt and chapter id.
    - Expect sequence: `started` → one or more `delta` → `usage` (optional) → `done` (implicit relay close).
  - `test_stop_cancels_and_emits_done`:
    - Connect and `start` with slow mock provider (`delay_s`).
    - Send `stop`; expect final `done` then close; `Suggestion.status` remains `pending`.
  - `test_invalid_start_payload_closes_with_error`:
    - Missing `prompt` or `chapter_id` → `error` then close code `4400`.
  - `test_duplicate_start_is_rejected`:
    - Second `start` → `error` then close.
  - `test_provider_error_flows_through`:
    - Mock provider with `error="boom"`; expect `error` then close; `Suggestion.status="rejected"`.

Note: Tests should use `apps.suggestions.providers.mock.MockProvider` injected into the service (as in BL-007 tests) to avoid network calls and make timing deterministic.

## TypeScript Contract (for frontend)
Event union emitted by server:
```ts
type SuggestionEvent =
  | { type: 'started'; session_id: string }
  | { type: 'delta'; value: string }
  | { type: 'usage'; prompt_tokens: number; completion_tokens: number; total_tokens: number }
  | { type: 'done' }
  | { type: 'error'; message: string; code?: string; retryable?: boolean };

type ClientMessage =
  | { type: 'start'; chapter_id: number; prompt: string; settings?: Partial<{ model: string; temperature: number; max_tokens: number | null; stop: string[] | null }>; context?: Partial<{ system_prompt: string; personas?: string[]; chapter_titles?: string[] }> }
  | { type: 'stop' };
```

## OpenAPI & Schema
- No REST schema changes in this ticket (WebSocket only).
- Documentation: ensure `docs/00-draft.md` and `01-technical-spec-en.md` reference the final path and message shapes.

## Acceptance Criteria
- WebSocket route(s) registered under `/ws/suggestions/` (and optional `/ws/suggestions/{session_id}/`).
- On `start`, server responds with `started` and streams normalized events until `done` or `error`.
- On `stop`, server cancels the underlying session and emits `done` before closing.
- Only a single `start` per connection; duplicates rejected with `error`.
- Clean shutdown: background tasks cancelled, sessions removed from service registry.
- Tests pass (consumer-level) with mock provider; no real network calls.

## Risks & Mitigations
- Race conditions on cancel: rely on `CancelToken` and ensure final `done` emission; persist synthetic `done` as in BL-007.
- Partial/malformed frames: validate inputs and close with `4400` to avoid undefined states.
- Backpressure: low event volume; `await send_json` suffices; can add bounded queue if needed.
- Reconnect/replay: out of scope; can later replay persisted `SuggestionEvent` history if required.

## Estimation
- Effort: M (1–2 days including consumer, routing, tests, and docs).

## Checklist
- [ ] `SuggestionsConsumer` implemented (`apps/suggestions/consumers.py`).
- [ ] Routes added in `liriac/routing.py`.
- [ ] Consumer tests using `channels.testing.WebsocketCommunicator`.
- [ ] Logging added for lifecycle events.
- [ ] Docs updated (`docs/00-draft.md` references verified).
- [ ] CI green (lint, typecheck, tests).
