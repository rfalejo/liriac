# Ticket BL-009: Autosave Service — Debounce, Idempotent Hash, Atomic Writes, Snapshots

## Description
Add an autosave service that schedules debounced, idempotent writes of chapter content to disk. The service runs in the Services layer, consumes the `ChapterRepository` port to persist content atomically, and writes snapshots under `.liriac/versions/` only when changes exceed a configured threshold. No TUI integration beyond callable APIs is required in this ticket; wiring from the editor will come later.

Goals:
- Debounced saves: coalesce rapid edits and write after a delay (default 10s).
- Idempotent hash: skip writes when normalized content hasn’t changed since last successful save.
- Atomic persistence: rely on the repository’s `write_chapter` which already uses atomic replace.
- Snapshots: write version files to `.liriac/versions/` only if diff length ≥ 100 characters (configurable).

Scope:
- Implement the service with clean, testable design (injectable debounce duration and safe timers).
- Keep business and IO minimal; no network calls.
- Strict typing across Services; no implicit `Any`.

Out of scope:
- TUI wiring (Editor triggers) — added in a later ticket.
- Suggestions, AI streaming, and metrics plumbing beyond optional counters.
- Cross-process locks; single-process semantics are sufficient.

## Acceptance Criteria
- Source layout (Services):
  - `src/liriac/services/autosave/__init__.py` exports public classes via `__all__`.
  - `src/liriac/services/autosave/scheduler.py` implements:
    - `class AutosaveScheduler` with:
      - `__init__(library_path: Path, repo: ChapterRepository, debounce_seconds: float = 10.0, snapshot_threshold: int = 100)`
      - `schedule(ref: ChapterRef, text: str) -> None`:
        - Normalizes text for hashing (ensure single trailing `\n`).
        - If content hash unchanged since last persisted write for `ref`, do nothing.
        - Otherwise, schedule a debounced save (reset the timer on repeated calls).
      - `flush(ref: ChapterRef | None = None) -> None`:
        - Immediately executes any pending save(s) for the given `ref` or all refs when `None`.
      - `shutdown(flush: bool = False) -> None`:
        - Cancels all timers; optionally flushes before canceling when `flush=True`.
      - Internals:
        - Keeps per-ref state: last_saved_hash, pending_timer, last_text.
        - Uses UTC timestamps for persistence metadata.
        - Never raises on cancellation; fail-fast on invalid input types.
    - Save action details:
      - Builds a `Chapter` entity using:
        - `id = ChapterId(stem)` from `ref.relative_path.stem`
        - `title = stem`
        - `updated_at = datetime.now(UTC)`
        - `text = last_text` (normalized with a single trailing newline)
      - Calls `repo.write_chapter(library_path, chapter)`.
      - Updates `last_saved_hash` on success.
      - Triggers snapshot via helper (see below) only when the character diff between previous saved text and the new text is ≥ `snapshot_threshold`.
  - `src/liriac/services/autosave/snapshots.py` implements:
    - `write_snapshot(base_dir: Path, ref: ChapterRef, content: str, now: datetime) -> Path`:
      - Writes a full-content snapshot file under `<book>/.liriac/versions/` with a filename like `YYYY-MM-DDTHH-MM-SSZ-<stem>.md` (UTC, safe for filesystem).
      - Ensures directories exist; writes UTF-8 with trailing newline; uses atomic replace (`os.replace`) via a temp file in the same directory.
      - Returns the created snapshot path.
    - No diff algorithm required; only thresholded trigger from the scheduler.
  - `src/liriac/services/autosave/writer.py` (optional thin helper):
    - A small utility to normalize content and compute `sha256` hashes:
      - `normalize_text(text: str) -> str` (ensures single trailing `\n`).
      - `content_hash(text: str) -> str` (hex sha256 of normalized text).
      - These functions are used by the scheduler (unit-testable in isolation).

- Behavior:
  - Debounce: multiple `schedule(...)` calls within the debounce window coalesce to a single write with the latest content.
  - Idempotency: identical normalized content does not cause writes or snapshots.
  - Snapshots: created only when the character-level absolute difference between previously persisted content and the new content is ≥ `snapshot_threshold`. For this ticket, simply compare lengths of the differing slice or use a naive absolute length difference between normalized strings; an exact diff algorithm is not required.
  - Atomicity: final writes and snapshots leave no `*.tmp` files behind; use `os.replace`.

- Typing and style:
  - Fully annotated; `mypy --strict` passes.
  - `ruff` and `black` pass with no changes after formatting.
  - No `print`; optional logging via existing JSON logger is acceptable but not required.

- Packaging:
  - No new runtime dependencies are introduced.

## Testing Strategy
- Unit tests (pytest) under `tests/services/test_autosave.py`:
  - Scheduler basics:
    - Schedules do not write immediately; `flush()` performs a single write.
    - Rapid multiple `schedule()` calls are coalesced; only the latest content is written.
  - Idempotent hash:
    - Scheduling the same normalized content twice results in a single write.
  - Snapshot threshold:
    - When content change length is below threshold, no files appear under `.liriac/versions/`.
    - When content change length equals or exceeds threshold, a snapshot file is created; filename includes UTC timestamp and ends with `.md`.
  - Atomic writes:
    - After `flush()`, no `*.tmp` files remain under `chapters/` or `.liriac/versions/`.
  - Integration with filesystem repo:
    - Use `FilesystemLibraryRepository` against a `tmp_path` library:
      - Create minimal `book.toml` and a chapter file.
      - Call `schedule(ref, new_text)` then `flush()` and assert chapter file contents and trailing newline.
  - Normalization and hashing:
    - `normalize_text` ensures exactly one trailing newline.
    - `content_hash` returns the same value for inputs differing only by trailing newlines.
  - Shutdown behavior:
    - `shutdown(flush=False)` cancels pending timers (no write occurs).
    - `shutdown(flush=True)` performs pending write before canceling.

- Test hygiene:
  - No network calls; filesystem only via `tmp_path`.
  - Use UTC-aware datetimes in assertions when reading timestamps from filenames if needed.
  - Avoid sleeps: use `flush()` to deterministically execute pending saves instead of waiting for timers.

- Quality gates:
  - `make fmt`, `make lint`, `make typecheck`, and `make test` all pass.
